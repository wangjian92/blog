---
title: java的接口类和抽象类的特点 
date: 2019-10-21
tags:
 - java
categories: 
 - backEnd
---

## java的接口类和抽象类的特点

### java中抽象类的特点：

1. 抽象类和抽象方法必须用关键字abstract修饰
2. 如果一个类中有抽象方法，那么这个类一定是抽象类
3. 抽象类中不一定有抽象方法
4. 抽象类中可以存在抽象方法
5. 抽象类中可以存在构造方法
6. 抽象类中可以存在普通属性、方法、静态属性和静态方法
7. 抽象类中的抽象方法需要有子类实现，如果子类不实现，则子类也需要定义为抽象的 

### java中接口的特点：
1. 接口中的方法，永远都被public来修饰（只能）
2. 接口中没有构造方法，也不能实例化接口对象
3. 接口中只有方法的声明，没有方法体
4. 接口中只有常量，如果定义变量，在编译的时候都会默认加上“public static final”
5. 接口中定义的方法都需要实现类来实现，如果实现类不能实现接口中的所有方法，则实现类需要定义为抽象类
6. 静态方法不能被子类重写（覆盖），因此接口中不定声明静态方法
7. 使用接口可以实现多继承

### 接口和抽象类的区别之处：
1. 接口中所有的方法隐含都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法
2. 类可以实现很多个接口，但是只能继承一个抽象类
3. 类可以不实现抽象类和接口声明的所有方法，在这种情况下，类也必须得声明成是抽象的
4. 抽象类可以在不提供接口方法实现的情况下实现接口
5. java接口中声明的变量默认都是final的（public static final（必须赋初始值）），抽象类可以包含非final变量
6. java接口中的成员函数默认都是public的（public abstract），抽象类中的成员函数可以是private，protected或者是public的
7. 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是如果它包含main方法的话是可以被调用的

接口可继承接口，不能继承类（抽象类和普通类） 抽象类可继承接口也可继承具体类（继承接口时可只实现部分方法）

非抽象类如果要实现一个接口，它必须要实现接口声明的所有方法。类可以不实现抽象类或接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。

::: tip
1. 静态方法不能被重写，不能被抽象
本地方法是本地代码实现的方法，不能是抽象
synchronize与方法的实现细节有关，抽象方法不能被synchronize修饰
2. 抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；
而接口中只是对方法的申明和常量的定义。
:::
 
## 接口是否可继承接口？抽象类是否可实现接口？抽象类是否科技城实体类（concrete class）
1. 接口是可以被接口继承的，即通过关键字extends声明一个接口是另一个接口的子接口。由于接口中的方法和常量都是public，子接口将继承父接口中的全部方法和常量。
2. 抽象类可以实现接口，当一个类声明实现一个接口而没有实现接口中所有的方法，那么这个必须是抽象类，即abstract类。
3. 抽象类是可以继承实体类。
 
 
## 构造器Cintructor是否可被override?是否可以被overload?
Constructor不能被继承，所以Constructor也就不能被override,但是可以overload
 
 
## java垃圾回收的优点和原理，写出两种垃圾回收可调用的方法

### java垃圾回收的优点：

它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存.

### java垃圾回收的原理： 
垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

### 两种方法是
System.gc()
Runtime.gc()
 
 
## 请说出你所知道的线程中常用的方法
1. wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
2. sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉 InterruptedException异常。
3. notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的 唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
4. notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁， 而是让它们竞争。
 
 
## Error与Exception的区别
Error表示系统级的错误和程序不必处理的异常， Exception表示需要捕捉或者需要程序进行处理的异常
 
 
## 在java中一个类被声明为final类型，表示了什么意思
意味着它不能再派生出新的子类，不能作为父类被继承
 
 
## 谈谈final,finally,finalize的区别
1. final—修饰符（关键字）
如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此 一个类不能既被声明为 abstract的，又被声明为final的。
2. 将变量或方法声明为final，可以保证它们在使用中不被改变。
被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改.被 声明为final的方法也同样只能使用，不能重载。
3. finally—再异常处理时提供 finally 块来执行任何清除操作。
如果抛出一个异常，那么相 匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。
4. finalize—方法名。
Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除 出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这 个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 
